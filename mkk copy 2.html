<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Falling Pickaxe Game</title>
    <style>
        canvas {
            background: #111;
            display: block;
            margin: 0 auto;
            border: 2px solid #444;
        }

        #chat {
            text-align: center;
            margin: 10px;
        }

        input {
            padding: 8px;
            width: 200px;
        }

        #ui {
            width: 400px;
            margin: 0 auto;
            color: white;
            font-family: Arial, sans-serif;
            font-size: 14px;
            margin-bottom: 10px;
        }

        #uiinventory {
            position: absolute;
            top: 10px;
            display: flex;
            justify-content: space-between;
            width: 320px;
        }

        #inventory {
            text-align: left;
            padding: 10px;
            background: #222;
            border-radius: 8px;
            color: white;
            font-family: monospace;
            font-size: 14px;
            /* max-width: 250px; */
            margin: 55px -82px auto;
        }

        #scoreStatus {
            display: flex;
            justify-content: space-between;
            background: #333;
            padding: 6px;
            margin-bottom: 5px;
        }

        #progress-container {
            height: 10px;
            background: #444;
            width: 100%;
            border: 1px solid #666;
        }

        #progress-fill {
            height: 100%;
            background: #00ccff;
            width: 0%;
            transition: width 0.3s ease;
        }
    </style>
</head>

<body>

    <div id="ui">
        <div id="uiinventory">
            <div id="inventory">
                <div id="stone">
                    <img src="sprites/blockTypes/stone.png" width="20" height="20" />
                    <span>stone: 0</span>
                </div>
                <div id="iron_ore">
                    <img src="sprites/iron.png" width="20" height="20" />
                    <span>iron ore: 0</span>
                </div>
                <div id="gold_ore">
                    <img src="sprites/gold.png" width="20" height="20" />
                    <span>gold ore: 0</span>
                </div>
                <div id="redstone_ore">
                    <img src="sprites/redstone.png" width="20" height="20" />
                    <span>redstone ore: 0</span>
                </div>
                <div id="diamond_ore">
                    <img src="sprites/diamond.png" width="20" height="20" />
                    <span>diamond ore: 0</span>
                </div>
                <div id="emerald_ore">
                    <img src="sprites/emerald.png" width="20" height="20" />
                    <span>emerald ore: 0</span>
                </div>
            </div>

        </div>

        <div id="scoreStatus">
            <div id="score">Score: 0</div>
            <div id="status">Status: -</div>
        </div>
        <div id="progress-container">
            <div id="progress-fill"></div>
        </div>
    </div>

    <canvas id="gameCanvas" width="400" height="600"></canvas>

    <div id="chat">
        <p>Type 'left' & 'l' or 'right' & 'r'</p>
        <input id="chatInput" placeholder="Type 'left' & 'l' or 'right' & 'r'" />
    </div>

    <script>
        const canvas = document.getElementById("gameCanvas");
        const ctx = canvas.getContext("2d");

        const BLOCK_WIDTH = 57;
        const BLOCK_HEIGHT = 59;
        const BLOCK_PADDING = 0;
        const BLOCK_COLS = Math.floor(canvas.width / (BLOCK_WIDTH + BLOCK_PADDING));
        const blockTypes = ['stone', 'iron_ore', 'gold_ore', 'redstone_ore', 'diamond_ore', 'emerald_ore'];

        let cameraY = 0;
        let score = 0;
        const scoreTarget = 100;

        let inventoryCounts = {};
        blockTypes.forEach(type => inventoryCounts[type] = 0);

        // Preloaded images
        const images = {};
        function preloadImages() {
            const allImages = {
                pickaxe: 'sprites/TypesPickaxe/pickaxe.png',
                stone: 'sprites/blockTypes/stone.png',
                iron_ore: 'sprites/blockTypes/iron_ore.png',
                gold_ore: 'sprites/blockTypes/gold_ore.png',
                redstone_ore: 'sprites/blockTypes/redstone_ore.png',
                diamond_ore: 'sprites/blockTypes/diamond_ore.png',
                emerald_ore: 'sprites/blockTypes/emerald_ore.png',
                tnt: 'sprites/TypesBlockEfek/tnt.png',
                // icon_stone: 'sprites/miner.png',
                // icon_iron_ore: 'sprites/iron.png',
                // icon_gold_ore: 'sprites/gold.png',
                // icon_redstone_ore: 'sprites/redstone.png',
                // icon_diamond_ore: 'sprites/diamond.png',
                // icon_emerald_ore: 'sprites/emerald.png',

            };
            for (const [key, src] of Object.entries(allImages)) {
                const img = new Image();
                img.src = src;
                images[key] = img;
            }
        }
        preloadImages();

        // Bounce & spin settings
        let normalBounceForce = -8;
        let normalHorizontalForce = 2;
        let tntBounceForce = -12;
        let tntHorizontalForce = 5;
        let normalSpinChance = 0.9;
        let tntSpinChance = 0.8;

        let pickaxe = {
            x: canvas.width / 2 - 15,
            y: 0,
            width: 30,
            height: 30,
            velocityY: 0,
            velocityX: 0,
            gravity: 0.5,
            gravityModifier: 1,
            modifierTimer: 0,
            modifierType: null,
            angle: 0,
            rotateSpeed: 0,
            targetX: canvas.width / 2 - 15
        };

        let blocks = [];

        function getRandomBlockType() {
            const rand = Math.random();
            if (rand < 0.05) return 'tnt';
            if (rand < 0.2) return 'powerup';
            if (rand < 0.3) return 'powerdown';
            return blockTypes[Math.floor(Math.random() * blockTypes.length)];
        }

        function generateBlocksBelow() {
            const startY = Math.floor((pickaxe.y + 600) / (BLOCK_HEIGHT + BLOCK_PADDING)) * (BLOCK_HEIGHT + BLOCK_PADDING);
            for (let y = startY; y < startY + 300; y += (BLOCK_HEIGHT + BLOCK_PADDING)) {
                for (let c = 0; c < BLOCK_COLS; c++) {
                    const blockX = c * (BLOCK_WIDTH + BLOCK_PADDING);
                    if (!blocks.find(b => b.y === y && b.x === blockX)) {
                        const type = getRandomBlockType();
                        blocks.push({
                            x: blockX,
                            y: y,
                            width: BLOCK_WIDTH,
                            height: BLOCK_HEIGHT,
                            hit: false,
                            type: type,
                            subtype: type
                        });
                    }
                }
            }
        }

        function drawHUD() {
            document.getElementById("score").innerText = "Score: " + score;
            if (pickaxe.modifierTimer > 0) {
                const label = pickaxe.modifierType === "powerup" ? "FAST" : "SLOW";
                document.getElementById("status").innerText = `Status: ${label} (${Math.ceil(pickaxe.modifierTimer / 60)}s)`;
            } else {
                document.getElementById("status").innerText = `Status: -`;
            }
            const percent = Math.min(100, (score / scoreTarget) * 100);
            document.getElementById("progress-fill").style.width = percent + "%";
        }

        function drawBlocks() {
            blocks.forEach(block => {
                if (!block.hit) {
                    if (blockTypes.includes(block.subtype)) {
                        const img = images[block.subtype];
                        if (img) {
                            ctx.drawImage(img, block.x, block.y - cameraY, block.width, block.height);
                            return;
                        }
                    }

                    let color = "#ffaa00";
                    // if (block.type === 'tnt') color = "#ff4444";
                    if (blockTypes.includes(block.subtype) || block.type === 'tnt') {
                        const key = block.type === 'tnt' ? 'tnt' : block.subtype;
                        const img = images[key];
                        if (img) {
                            ctx.drawImage(img, block.x, block.y - cameraY, block.width, block.height);
                            return;
                        }
                    }
                    if (block.type === 'powerup') color = "#44ff44";
                    if (block.type === 'powerdown') color = "#4488ff";
                    ctx.fillStyle = color;
                    ctx.fillRect(block.x, block.y - cameraY, block.width, block.height);
                }
            });
        }

        function drawPickaxe() {
            ctx.save();
            ctx.translate(pickaxe.x + pickaxe.width / 2, pickaxe.y - cameraY + pickaxe.height / 2);
            ctx.rotate(pickaxe.angle);
            ctx.drawImage(images.pickaxe, -pickaxe.width / 2, -pickaxe.height / 2, pickaxe.width, pickaxe.height);
            ctx.restore();
        }

        function explodeAround(tntBlock) {
            blocks.forEach(block => {
                const isAdjacent =
                    (Math.abs(block.x - tntBlock.x) === (BLOCK_WIDTH + BLOCK_PADDING) && block.y === tntBlock.y) ||
                    (Math.abs(block.y - tntBlock.y) === (BLOCK_HEIGHT + BLOCK_PADDING) && block.x === tntBlock.x);
                if (isAdjacent && !block.hit) {
                    block.hit = true;
                    score++;
                    if (blockTypes.includes(block.subtype)) {
                        inventoryCounts[block.subtype]++;
                        updateInventoryUI();
                    }
                }
            });
        }

        function checkCollision() {
            blocks.forEach(block => {
                if (!block.hit &&
                    pickaxe.x < block.x + block.width &&
                    pickaxe.x + pickaxe.width > block.x &&
                    pickaxe.y < block.y + block.height &&
                    pickaxe.y + pickaxe.height > block.y
                ) {
                    block.hit = true;
                    score++;

                    if (blockTypes.includes(block.subtype)) {
                        inventoryCounts[block.subtype]++;
                        updateInventoryUI();
                    }

                    // Arahkan pantulan sesuai arah datang
                    const direction = (pickaxe.x + pickaxe.width / 2) < (block.x + block.width / 2) ? -1 : 1;

                    if (block.type === 'normal' || blockTypes.includes(block.type)) {
                        pickaxe.velocityY = normalBounceForce;
                        if (Math.random() < normalSpinChance) {
                            pickaxe.velocityX = direction * (normalHorizontalForce + Math.random() * 2);
                            pickaxe.rotateSpeed = 0.05 + Math.random() * 0.05;
                        }
                    }

                    if (block.type === 'tnt') {
                        explodeAround(block);
                        pickaxe.velocityY = tntBounceForce;
                        if (Math.random() < tntSpinChance) {
                            pickaxe.velocityX = direction * (tntHorizontalForce + Math.random() * 2);
                            pickaxe.rotateSpeed = 0.2 + Math.random() * 0.2;
                        }
                    }

                    if (block.type === 'powerup') {
                        pickaxe.gravityModifier = 2;
                        pickaxe.modifierTimer = 300;
                        pickaxe.modifierType = "powerup";
                    }

                    if (block.type === 'powerdown') {
                        pickaxe.gravityModifier = 0.1;
                        pickaxe.modifierTimer = 300;
                        pickaxe.modifierType = "powerdown";
                    }
                }
            });
        }

        function updateInventoryUI() {
            for (const key of blockTypes) {
                const span = document.querySelector(`#${key} span`);
                if (span) {
                    span.textContent = `${inventoryCounts[key]}`;
                }
            }
        }

        function update() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (pickaxe.modifierTimer > 0) {
                pickaxe.modifierTimer--;
                if (pickaxe.modifierTimer === 0) {
                    pickaxe.gravityModifier = 1;
                    pickaxe.modifierType = null;
                }
            }

            pickaxe.velocityY += pickaxe.gravity * pickaxe.gravityModifier;
            pickaxe.y += pickaxe.velocityY;

            pickaxe.velocityX *= 0.98;
            pickaxe.x += pickaxe.velocityX;

            pickaxe.x += (pickaxe.targetX - pickaxe.x) * 0.05;

            if (pickaxe.rotateSpeed > 0) {
                pickaxe.angle += pickaxe.rotateSpeed;
                pickaxe.rotateSpeed *= 0.98;
                if (pickaxe.rotateSpeed < 0.01) pickaxe.rotateSpeed = 0;
            }

            if (pickaxe.y + pickaxe.height > canvas.height + cameraY) {
                pickaxe.y = canvas.height + cameraY - pickaxe.height;
                pickaxe.velocityY = normalBounceForce;
            }

            pickaxe.x = Math.max(0, Math.min(canvas.width - pickaxe.width, pickaxe.x));

            cameraY = pickaxe.y - 200;

            generateBlocksBelow();
            checkCollision();
            drawBlocks();
            drawPickaxe();
            drawHUD();

            requestAnimationFrame(update);
        }

        document.getElementById("chatInput").addEventListener("keydown", (e) => {
            if (e.key === "Enter") {
                const cmd = e.target.value.trim().toLowerCase();
                if (cmd === "left" || cmd === "l") {
                    pickaxe.targetX = Math.max(0, pickaxe.x - 30);
                } else if (cmd === "right" || cmd === "r") {
                    pickaxe.targetX = Math.min(canvas.width - pickaxe.width, pickaxe.x + 30);
                }
                e.target.value = "";
            }
        });

        updateInventoryUI();
        update();
    </script>


</body>

</html>